library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all; 

entity fetchLogic_tb is
end entity fetchLogic_tb;

architecture tb of fetchLogic_tb is
    constant CLOCK_PERIOD : time := 10 ns;
    
    signal clk, reset, j, jal, jReg, brEQ, brNE, ALU0 : std_logic;
    signal pAddr, pInst, nAddr, jRetReg : std_logic_vector(31 downto 0);
    
begin
    uut: entity work.fetchLogic
        port map(
            i_clk => clk,
            i_reset => reset,
            i_j => j,
            i_jal => jal,
            i_jReg => jReg,
            i_jRetReg => jRetReg,
            i_brEQ => brEQ,
            i_brNE => brNE,
            i_ALU0 => ALU0,
            i_pAddr => pAddr,
            i_pInst => pInst,
            o_nAddr => nAddr
        );

    -- Clock process
    clk_process: process
    begin
        while now < 500 ns loop
            clk <= '0';
            wait for CLOCK_PERIOD / 2;
            clk <= '1';
            wait for CLOCK_PERIOD / 2;
        end loop;
        wait;
    end process;

    -- Stimulus process
    stim_process: process
    begin
        -- Initialize inputs
        reset <= '1';
        wait for 20 ns;
        reset <= '0';

        -- Test cases
        wait for CLOCK_PERIOD * 5;
        -- Example test case: jump instruction
        pAddr <= x"00000000";  -- Program Counter initial value
        pInst <= x"08000000";  -- Jump instruction
        j <= '1';  -- Jump signal
        jReg <= '0';  -- No jump register signal
        wait for CLOCK_PERIOD;
        -- Expected result: Next address should be 0x08000000
        assert nAddr = x"08000000" report "Jump instruction failed" severity error;

        -- Add more test cases here

        wait;
    end process;
end architecture tb;
